#!/usr/bin/env python
#
################################################################################
#
# IV_Swinger.py: IV Swinger control program
#
# Copyright (C) 2015  Chris Satterlee
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
################################################################################
#
# The IV Swinger is an open source hardware and software project
#
# Permission to use the hardware design is granted under the terms of
# the TAPR Open Hardware License Version 1.0 (May 25, 2007) -
# http://www.tapr.org/OHL
# 
# Permission to use the software is granted under the terms of the GNU
# GPL v3 as noted above.
# 
# Current versions of the licensing files, documentation, Fritzing file
# (hardware description), and software can be found at:
# 
#    https://github.com/csatt/IV_Swinger 
#
################################################################################
#
# This file contains the Python code that controls the IV Swinger
# hardware, captures measurements, and displays the results graphically.
#
# The hardware consists of a chain of loads that are selected or
# deselected using relays.  When a load is deselected, the current
# passes through a wire bypassing that load.  Ideally when all loads are
# deselected, the resistance of the chain would be zero (short circuit).
# In reality the bypass wires, relay terminal connections, and relay
# contacts have small resistances that add up to a non-negligible total
# (close to half an ohm).
#
# There are 16 relays (two 8-relay Sainsmart-type modules) which are
# driven by a MCP23017 I/O extender IC that is controlled from the
# Raspberry Pi i2c bus.  The MCP23017 outputs are connected to the
# relays as follows.  This list in is order from RIGHT to LEFT as seen
# from the front of the box.
#
# MCP23017  Relay pin         Load (see defines below)
# --------  ---------         ----
#  B0       Module 1, IN1     HALF
#  B1       Module 1, IN2     OPEN
#  B2       Module 1, IN3     ONE
#  B3       Module 1, IN4     TWO
#  B4       Module 1, IN5     THREE
#  B5       Module 1, IN6     FOUR
#  B6       Module 1, IN7     FIVE
#  B7       Module 1, IN8     SIX
#  A7       Module 0, IN1     SEVEN
#  A6       Module 0, IN2     EIGHT
#  A5       Module 0, IN3     NINE
#  A4       Module 0, IN4     TEN
#  A3       Module 0, IN5     ELEVEN
#  A2       Module 0, IN6     TWELVE
#  A1       Module 0, IN7     THIRTEEN
#  A0       Module 0, IN8     FOURTEEN
#
# Note that one of the "loads" (OPEN) is actually not connected.  This
# was a design change required to support maximizing the lifetime of the
# relay contacts. The load bank does include a coil associated with this
# relay, but one of its leads is simply left unconnected so that when
# the relay is activated the circuit is open. The OPEN load is in the
# second position purely for logistical reasons; it was the easiest one
# to disconnect when the decision was made to implement the change.
#
# There is a double-pole single-throw (DPST) switch in the load circuit
# that has two purposes: 1) on one side it opens and closes the load
# circuit, and 2) on the other side it is connected to a GPIO pin so the
# code can sense whether the load circuit is open or closed and can poll
# for changes.  While the load circuit is open, the code continuously
# measures the voltage and records the last value before it detects that
# the switch was flipped - this is the Voc value.  Then it starts into a
# loop of incrementally adding to the load value and at each increment
# measuring and recording the current (I) and the voltage (V). 
#
# The ADS1115 analog-to-digital converter (ADC) is used for both the
# voltage and current measurements.  The ADS1115 is also controlled and
# read via the Raspberry Pi i2c bus.  Since the voltage generated by a
# PV panel can be much higher than the 5V maximum ADC input voltage, the
# actual voltage that is fed to the ADC input is divided down from the
# PV inputs using series resistors (classic voltage divider).  The
# software then scales that back up to the original voltage.  The
# current measurement is actually a voltage measurement too - across a
# low resistance (7.5 milliohm) "shunt resistor".  The current is
# calculated from Ohm's Law using the measured voltage and the known
# precision resistance of the shunt resistor.  This voltage is very
# small however (75mV for 10A) so it is amplified using a simple (and
# also classic) non-inverting op amp circuit before being fed to the ADC
# input.  The software does the math of converting the voltage value
# read by the ADC to a measured value for the current.
#
# Each of the measured I-V pairs is recorded for each selected load
# value.  Two important points are where V=0 and where I=0.  The current
# when V=0 is the short-circuit current, Isc.  The voltage when I=0 is
# the open-circuit voltage Voc.  Voc is captured when the DPST switch is
# in the open position.  Since there is still a small resistance when
# the circuit is closed - even with zero loads selected, the Isc value
# is estimated by a linear extrapolation from that "zero" load point and
# the next point (minimum load selected - "HALF").
#
# When the program is started the DPST switch is expected to be in the
# OFF (open) position.  If it is not, it prompts the user to turn it
# off, sounding a warning (piezo buzzer) until this has happened. When
# the switch is off, the program measures Voc. When Voc is stable it
# then asks the user to turn ON (close) the DPST switch, polling until
# this has happened.  During this polling the Voc value is continually
# updated since it could be changing.  When the switch is closed, the
# program begins the loop incrementing the load value and measuring the
# current and voltage at each point. The original code toggled the HALF
# relay at every increment to get ~1/2 ohm steps. But this results in a
# drastically shorter lifetime for this one relay. Now there are both
# "fine" and "coarse" modes.  The "coarse" mode starts with the HALF
# load, but only takes full steps after that. Even in "fine" mode, the
# HALF relay isn't switched at every step. Where the code determines
# that the curve is relatively straight (typically at the beginning and
# the end), it skips the half load values since they don't add value.
# This turns out to be a very good optimization - most of the time there
# are only two added points relative to coarse mode.  For this reason,
# the default is fine mode.  Coarse mode should probably be removed, but
# it has been left in.  The user can toggle the mode by pressing the
# pushbutton briefly.
##
# The recorded values are written to a CSV file on both the Raspberry
# Pi's SD card file system and also on one or more USB thumb drives.
# The USB thumb drive(s) can then be removed and inserted in an external
# computer to import the CSV to Excel and/or to perform other analysis.
# Note that if more than one USB drive is found, the files are written
# to ALL of them.  This is to save time when the IV Swinger is used in a
# educational lab setting where there may be multiple lab partners.
# There are four USB ports, so up to four students can use their own USB
# thumb drives and no one has to copy the files from anyone else. The
# files are written to the /IV_Swinger directory on the SD card and all
# USB drives.  The subdirectory under /IV_Swinger is named for the date
# and time that the measurement was taken (yymmdd_hh_mm_ss)
# e.g. directory /IV_Swinger/141213_09_33_31 contains files for a
# measurement taken on December 13th, 2014 at 9:33:13 am.
#
# The program also uses gnuplot to generate a graph of the IV curve that
# it writes to a PDF file, which is also copied to the USB drive(s) in
# the same directory.
#
# If the DPST switch remains OFF (open) for more than 10 minutes, the
# program initiates a shutdown of the Raspberry Pi.  There is also a
# shutdown pushbutton switch that is monitored at all times; when it is
# pressed and held for more than 3 seconds the program does an immediate
# shutdown of the Raspberry Pi.
#
import sys, os, traceback, math, glob, shutil, threading
from time import sleep, time
from subprocess import call
from datetime import datetime
import RPi.GPIO as GPIO
from Adafruit_MCP230xx import *
from Adafruit_ADS1x15 import ADS1x15
from Adafruit_CharLCD import Adafruit_CharLCD
from PyPDF2 import PdfFileMerger

#################
### Constants ###
#################

# Diagnostic mode control
DIAG_MODE = False

# Headless mode control
HEADLESS_MODE = True
IDLE_TIMEOUT_SECONDS = 600
IDLE_TIMEOUT_WARNING_SECONDS = 30

# FINE MODE control
#
# FINE mode produces better results but wears out the HALF relay faster.
# However, with the adaptive algorithm that only adds the half steps
# where the curve is bending, most runs only add two extra points in
# FINE mode, so we'll go with this as the default now. If
# FINE_MODE_TOGGLE is True, pushbutton can be used to toggle mode.
FINE_MODE = True
FINE_MODE_TOGGLE = False

# GPIO defines
DPST_GPIO = 4       # DPST switch is connected to GPIO 04 (BCM)
DPST_ON = True
DPST_OFF = False
BUTTON_GPIO = 5     # Pushbutton is connected to GPIO 05 (BCM)
BUTTON_ON = True
BUTTON_OFF = False
BUTTON_TIME_FOR_SHUTDOWN = 3
BUZZER_GPIO = 18    # Piezo buzzer is connected to GPIO 18 (BCM)

# LCD display defines
LCD_LINES = 2
LCD_DISPLAY_CHARS_PER_LINE = 16
LCD_MEM_CHARS_PER_LINE = 40
LCD_CHARS_PER_SCROLL = 4  # Must be integer divisor of 24 (1,2,3,4,6,8,12)
LCD_SCROLL_DELAY = 1.2

# I/O extender (MCP23017 on Slice of PI/O) defines
MCP23017_I2C_ADDR  = 0x20  # Slice of PI/O jumpered to default
MCP23017_PIN_COUNT = 16    # MCP23017 is 16 GPIO extension

# Relay defines
RELAY_OFF      = 1  # Relays are active low
RELAY_ON       = 0
ALL_RELAYS_OFF = 0xFFFF

# Load pattern defines
#
# There are 16 loads.  The basic "unit" loads are the immersion coils
# (~0.9 ohm each).  The first load in the chain is two of these in
# parallel, i.e. half a unit load.  The next one is the "open" load,
# which is not connected to anything (this was a late design
# change). The next eleven are unit loads.  The last three loads in the
# chain consist of 6 ohm resistors.  Number 12 is two of these in
# parallel (3 ohms).  Number 13 is one 6 ohm resistor.  Number 14 is two
# in series (12 ohms).
#
NONE                = 0x0000  # No loads selected.  Resistance is only relays/wires
HALF_ONLY           = 0x8000
OPEN_ONLY           = 0x4000
ONE_ONLY            = 0x2000
TWO_ONLY            = 0x1000
THREE_ONLY          = 0x0800
FOUR_ONLY           = 0x0400
FIVE_ONLY           = 0x0200
SIX_ONLY            = 0x0100
SEVEN_ONLY          = 0x0080
EIGHT_ONLY          = 0x0040
NINE_ONLY           = 0x0020
TEN_ONLY            = 0x0010
ELEVEN_ONLY         = 0x0008
TWELVE_ONLY         = 0x0004
THIRTEEN_ONLY       = 0x0002
FOURTEEN_ONLY       = 0x0001

HALF                = NONE     + HALF_ONLY      # 1/2 unit load selected
ONE                 = NONE     + ONE_ONLY       # 1 unit load selected
TWO                 = ONE      + TWO_ONLY       # 2 unit loads selected
THREE               = TWO      + THREE_ONLY     # 3 unit loads selected
FOUR                = THREE    + FOUR_ONLY      # 4 unit loads selected
FIVE                = FOUR     + FIVE_ONLY      # 5 unit loads selected
SIX                 = FIVE     + SIX_ONLY       # 6 unit loads selected
SEVEN               = SIX      + SEVEN_ONLY     # 7 unit loads selected
EIGHT               = SEVEN    + EIGHT_ONLY     # 8 unit loads selected
NINE                = EIGHT    + NINE_ONLY      # 9 unit loads selected
TEN                 = NINE     + TEN_ONLY       # 10 unit loads selected
ELEVEN              = TEN      + ELEVEN_ONLY    # 11 unit loads selected
TWELVE              = ELEVEN   + TWELVE_ONLY    # 11 unit loads + 3 ohm load selected
THIRTEEN            = TWELVE   + THIRTEEN_ONLY  # 11 unit loads + 3 ohm + 6 ohm loads selected
FOURTEEN            = THIRTEEN + FOURTEEN_ONLY  # 11 unit loads + 3 ohm + 6 ohm + 12 ohm loads selected

ONE_AND_A_HALF      = ONE      + HALF           # 1.5 unit load selected
TWO_AND_A_HALF      = TWO      + HALF           # 2.5 unit loads selected
THREE_AND_A_HALF    = THREE    + HALF           # 3.5 unit loads selected
FOUR_AND_A_HALF     = FOUR     + HALF           # 4.5 unit loads selected
FIVE_AND_A_HALF     = FIVE     + HALF           # 5.5 unit loads selected
SIX_AND_A_HALF      = SIX      + HALF           # 6.5 unit loads selected
SEVEN_AND_A_HALF    = SEVEN    + HALF           # 7.5 unit loads selected
EIGHT_AND_A_HALF    = EIGHT    + HALF           # 8.5 unit loads selected
NINE_AND_A_HALF     = NINE     + HALF           # 9.5 unit loads selected
TEN_AND_A_HALF      = TEN      + HALF           # 10.5 unit loads selected
ELEVEN_AND_A_HALF   = ELEVEN   + HALF           # 11.5 unit loads selected
TWELVE_AND_A_HALF   = TWELVE   + HALF           # 11.5 unit loads + 3 ohm load selected
THIRTEEN_AND_A_HALF = THIRTEEN + HALF           # 11.5 unit loads + 3 ohm + 6 ohm loads selected
FOURTEEN_AND_A_HALF = FOURTEEN + HALF           # 11.5 unit loads + 3 ohm + 6 ohm + 12 ohm loads selected

# In some cases where the ratio of Voc to Isc is high (e.g. low
# insolation), it's better to start off with a "base" load using one or
# more of the power resistors.  This pushes the fine grained sampling to
# the right, where the knee of the curve is.
BASE_0_OHM          = [NONE]
BASE_3_OHM          = [TWELVE_ONLY]
BASE_6_OHM          = [THIRTEEN_ONLY]
BASE_9_OHM          = [THIRTEEN_ONLY, TWELVE_ONLY]
BASE_12_OHM         = [FOURTEEN_ONLY]
BASE_15_OHM         = [FOURTEEN_ONLY, TWELVE_ONLY]
BASE_18_OHM         = [FOURTEEN_ONLY, THIRTEEN_ONLY]
BASE_21_OHM         = [FOURTEEN_ONLY, THIRTEEN_ONLY, TWELVE_ONLY]

# The 6 ohm resistors are rated at 50W.  We assume that they can handle
# at least 100W for a couple seconds.  The 3 ohm load is two in
# parallel, so it can handle 200W.  The 12 ohm load is two in series, so
# it can also handle 200W. Since power is I^2*R, here are the current
# limits for each of these loads:
#
#  TWELVE (3 ohm):    sqrt(200W/3ohm)  = 8 amps
#  THIRTEEN (6 ohm):  sqrt(100W/6ohm)  = 4 amps
#  FOURTEEN (12 ohm): sqrt(200W/12ohm) = 4 amps
#
TWELVE_MAX_AMPS     = 8
THIRTEEN_MAX_AMPS   = 4
FOURTEEN_MAX_AMPS   = 4

coarse_load_list = [NONE,
                    HALF,
                    ONE_AND_A_HALF,
                    TWO_AND_A_HALF,
                    THREE_AND_A_HALF,
                    FOUR_AND_A_HALF,
                    FIVE_AND_A_HALF,
                    SIX_AND_A_HALF,
                    SEVEN_AND_A_HALF,
                    EIGHT_AND_A_HALF,
                    NINE_AND_A_HALF,
                    TEN_AND_A_HALF,
                    ELEVEN_AND_A_HALF,
                    TWELVE_AND_A_HALF,
                    THIRTEEN_AND_A_HALF,
                    FOURTEEN_AND_A_HALF]

fine_load_list = [NONE,
                  HALF,
                  ONE_AND_A_HALF,
                  ONE,                # skip if prev is in line
                  TWO_AND_A_HALF,
                  TWO,                # skip if prev is in line
                  THREE_AND_A_HALF,
                  THREE,              # skip if prev is in line
                  FOUR_AND_A_HALF,
                  FOUR,               # skip if prev is in line
                  FIVE_AND_A_HALF,
                  FIVE,               # skip if prev is in line
                  SIX_AND_A_HALF,
                  SIX,                # skip if prev is in line
                  SEVEN_AND_A_HALF,
                  SEVEN,              # skip if prev is in line
                  EIGHT_AND_A_HALF,
                  EIGHT,              # skip if prev is in line
                  NINE_AND_A_HALF,
                  NINE,               # skip if prev is in line
                  TEN_AND_A_HALF,
                  TEN,                # skip if prev is in line
                  ELEVEN_AND_A_HALF,
                  ELEVEN,             # skip if prev is in line
                  TWELVE_AND_A_HALF,
                  THIRTEEN_AND_A_HALF,
                  FOURTEEN_AND_A_HALF]

diag_load_list = [NONE,
                  HALF_ONLY,
                  OPEN_ONLY,
                  ONE_ONLY,
                  TWO_ONLY,
                  THREE_ONLY,
                  FOUR_ONLY,
                  FIVE_ONLY,
                  SIX_ONLY,
                  SEVEN_ONLY,
                  EIGHT_ONLY,
                  NINE_ONLY,
                  TEN_ONLY,
                  ELEVEN_ONLY,
                  TWELVE_ONLY,
                  THIRTEEN_ONLY,
                  FOURTEEN_ONLY]

#TIME_BETWEEN_MEASUREMENTS = 0.2
TIME_BETWEEN_MEASUREMENTS = 0.05
SAMPLES_PER_MEASUREMENT = 2
MAX_RETRIES = 0

### Misc ###
INFINITE_VAL = 99999999
VOC_SETTLE_COUNT = 5

### ADC ###
ADS1115 = 0x01	# 16-bit ADC

# List of PGA gains (max +- mV)
pga_list = [6144, 4096, 2048, 1024, 512, 256]

# Select the sample rate
sps_list = [8, 16, 64, 128, 250, 475, 860] # legal values
sps = 250  # 250 samples per second

### Voltage divider ###
#
# The voltage divider consists of 3 resistors rather than the typical 2:
#
#  PV+  ---O
#          |
#          |
#          >           o +5V
#          <  R1       |
#          >          --- Schottky diode #1
#          |           A
#          |           |
#          o-----------o----> ADC A0 input
#          |           |
#          |          --- Schottky diode #2
#          |           A
#          |           |
#          >           o GND
#          <  R2
#          >
#          |           o +5V
#          |           |
#          |          --- Schottky diode #3
#          |           A
#          |           |
#          o-----------o----> ADC A1 input
#          |           |
#          |          --- Schottky diode #4
#          >           A
#          <  R3       |
#          >           o GND
#          |
#          |
#  PV-  ---O
#
# The ADC differential inputs A0 and A1 measure the voltage across
# resistor R2.  The Schottky diode clamps assure that the voltage seen
# at the ADC inputs cannot be greater than +5V (plus Vfwd of diode) or
# less than 0V (minus Vfwd of diode). This protects the ADC inputs. The
# reason for resistor R3 is to limit the current in the event that the
# PV is connected backwards.  Without R3, if PV- is > +5V, current would
# flow through Schottky diode #3 into the +5V rail and there might not
# be enough load to sink that much current, which could damage the
# battery pack.
#
# The equation for a three-resistor voltage divider where the output is
# measured across the middle (R2) resistor is:
#
#              R2                           R1+R2+R3
#   Vout = ---------- * Vin    OR    Vin = ---------- * Vout
#           R1+R2+R3                           R2
#
# The ADC measures Vout and we want to know Vin, which is the PV
# voltage. So we use the second equation.
#
VDIV_R1 = 178900.0 # 180k - tweaked based on DMM measurement
VDIV_R2 = 8200.0   # 8.2k - tweaked based on DMM measurement
VDIV_R3 = 5595.0   # 5.6k - tweaked based on DMM measurement
VDIV_MULT = (VDIV_R1 + VDIV_R2 + VDIV_R3)/ VDIV_R2
VDIV_CHP = 0
VDIV_CHN = 1

### Ammeter ###
AMM_OP_AMP_RF = 82100.0  # Rf = 82k - tweaked based on DMM measurement
AMM_OP_AMP_RG = 1499.0   # Rg = 1.5k - tweaked based on DMM measurement
AMM_OP_AMP_GAIN = 1 + (AMM_OP_AMP_RF/AMM_OP_AMP_RG)
AMM_SHUNT_MAX_VOLTS = 0.075
AMM_SHUNT_MAX_AMPS = 10
AMM_SHUNT_RESISTANCE = AMM_SHUNT_MAX_VOLTS / AMM_SHUNT_MAX_AMPS
AMM_CHP = 2
AMM_CHN = 3

### Data point list ###
AMPS_DATA_POINT = 0
VOLTS_DATA_POINT = 1
OHMS_DATA_POINT = 2
WATTS_DATA_POINT = 3

### gnuplot ###
PLOT_IDEAL_CURVE = 0
PLOT_INTERPOLATED_CURVE = 1
PLOT_SMOOTHED_CURVE = 0

#################
### Classes   ###
#################

# The StoppableThread class is from pibrella.py
# (https://github.com/pimoroni/pibrella).

## Basic stoppable thread wrapper (from pibrella.py on
## https://github.com/pimoroni/pibrella).
#
#  Adds Event for stopping the execution loop and exiting cleanly.
class StoppableThread(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.stop_event = threading.Event()
        self.daemon = True

    def start(self):
        if self.isAlive() == False:
            self.stop_event.clear()
            threading.Thread.start(self)

    def stop(self):
        if self.isAlive() == True:
            # set event to signal thread to terminate
            self.stop_event.set()
            # block calling thread until thread really has terminated
            self.join()

## Class to continuously scroll a message until signalled to stop
#
#  Subclass of StoppableThread that calls the scrolling_message function
#  until signalled to stop. The text parameter accepts either a single
#  string or a list of strings.  In the latter case, each string in the
#  list is displayed in sequence with scrolling.
class ScrollingMessage(StoppableThread):
    def __init__(self, text, lcd, beep, lock):
        StoppableThread.__init__(self)
        self.text = text
        self.lcd = lcd
        self.beep = beep
        self.lock = lock

    def run(self):
        text_list = [self.text]
        if type(self.text) is list:
            text_list = self.text
        while self.stop_event.is_set() == False:
            for text in text_list:
                scrolling_message(text, self.lcd, self.stop_event,
                                  repeat_count=0, beep=self.beep,
                                  lock=self.lock)

## Class to continuously sound a warning until signalled to stop
#
#  Subclass of StoppableThread that calls the generate_beep function
#  until signalled to stop
class SoundWarning(StoppableThread):
    def __init__(self, on_time, off_time):
        StoppableThread.__init__(self)
        self.on_time = on_time
        self.off_time = off_time

    def run(self):
        while self.stop_event.is_set() == False:
            generate_beep(self.on_time, self.off_time, self.stop_event)


#################
### Functions ###
#################

# ------------------------------------------------------------------------------
def print_and_log(print_str):
    """Function to print to the screen (if there is one) and also to a
log file
"""
    global log_file_name

    # Print to screen
    print print_str

    # Print to log file with timestamp
    date_time_str = datetime.now().strftime('%y%m%d_%H_%M_%S')
    with open(log_file_name, "a") as f:
        f.write("\n" + date_time_str + ": " + print_str);


# -----------------------------------------------------------------------------
def log(print_str):
    """Function to print to the log file only
"""
    global log_file_name

    # Print to log file with timestamp
    date_time_str = datetime.now().strftime('%y%m%d_%H_%M_%S')
    with open(log_file_name, "a") as f:
        f.write("\n" + date_time_str + ": " + print_str);


# ------------------------------------------------------------------------------
def set_up_gpio():
    """Function to set up the GPIO pins"""

    # Set GPIO pin numbering to BCM mode
    GPIO.setmode(GPIO.BCM)

    # Set GPIO pin connected to DPST switch to be an input
    GPIO.setup(DPST_GPIO, GPIO.IN)

    # Set GPIO pin connected to pushbutton switch to be an input and
    # register its callback function
    GPIO.setup(BUTTON_GPIO, GPIO.IN)
    GPIO.add_event_detect(BUTTON_GPIO, GPIO.RISING,
                          callback=pushbutton_callback,
                          bouncetime=300)

    # Set GPIO pin connected to piezo buzzer to be an output
    GPIO.setup(BUZZER_GPIO, GPIO.OUT)
    GPIO.output(BUZZER_GPIO, False)

# ------------------------------------------------------------------------------
def pushbutton_callback (channel):
    """Callback function invoked when the pushbutton switch is pressed"""
    global global_lock, FINE_MODE, FINE_MODE_TOGGLE

    # Filter out phantom presses
    if GPIO.input(BUTTON_GPIO) == DPST_OFF:
        return

    # Acquire the global lock
    global_lock.acquire()

    # Reset the LCD just in case it is messed up
    reset_lcd(lcd)

    # Create the ScrollingMessage object with lock=None so we don't
    # deadlock
    msg_text = "Hold button %d s\nto shut down" % BUTTON_TIME_FOR_SHUTDOWN
    lcd_msg = ScrollingMessage(msg_text, lcd, beep=False, lock=None)
    lcd_msg.start()

    # If the button is still pressed, time how long it is pressed - up
    # to BUTTON_TIME_FOR_SHUTDOWN seconds.
    start_time = time.time()
    pressed_time = 0
    while (GPIO.input(BUTTON_GPIO) == DPST_ON and
           pressed_time < BUTTON_TIME_FOR_SHUTDOWN):
        pressed_time = time.time() - start_time

    # Stop the message
    lcd_msg.stop()

    # If the button was pressed for at least BUTTON_TIME_FOR_SHUTDOWN
    # seconds, print a dying message and shut down the RPi.  Otherwise,
    # print a message that the button was released before the shutdown
    # was initiated and toggle FINE_MODE.
    if pressed_time >= BUTTON_TIME_FOR_SHUTDOWN:
        msg_text = "Shutting down\nnow!!"
        lcd_msg = ScrollingMessage(msg_text, lcd, beep=True, lock=None)
        lcd_msg.start()
        sleep(2)
        os.system("shutdown -h now")
        # The following are only needed if the previous line is
        # commented out
        lcd_msg.stop()
        reset_lcd(lcd)
        sleep(5)
    else:
        msg_text = ["Button released\nbefore %d seconds" % BUTTON_TIME_FOR_SHUTDOWN]
        if FINE_MODE_TOGGLE:
            if FINE_MODE:
                FINE_MODE = False
                msg_text.append("**COARSE MODE**")
            else:
                FINE_MODE = True
                msg_text.append("**FINE MODE**")
        lcd_msg = ScrollingMessage(msg_text, lcd, beep=True, lock=None)
        lcd_msg.start()
        sleep(1)
        lcd_msg.stop()

    # Release the global lock.
    global_lock.release()

    return

# ------------------------------------------------------------------------------
def reset_lcd(lcd):
    """Function to reset the LCD"""
    # Code taken from Adafruit_CharLCD constructor

    lcd.write4bits(0x33)  # initialization
    lcd.write4bits(0x32)  # initialization
    lcd.write4bits(0x28)  # 2 line 5x7 matrix
    lcd.write4bits(0x0C)  # turn cursor off 0x0E to enable cursor
    lcd.write4bits(0x06)  # shift cursor right

    lcd.displaycontrol = lcd.LCD_DISPLAYON | lcd.LCD_CURSOROFF | lcd.LCD_BLINKOFF

    lcd.displayfunction = lcd.LCD_4BITMODE | lcd.LCD_1LINE | lcd.LCD_5x8DOTS
    lcd.displayfunction |= lcd.LCD_2LINE

    # Initialize to default text direction (for romance languages)
    lcd.displaymode = lcd.LCD_ENTRYLEFT | lcd.LCD_ENTRYSHIFTDECREMENT
    lcd.write4bits(lcd.LCD_ENTRYMODESET | lcd.displaymode)  # set the entry mode

    lcd.clear()

# ------------------------------------------------------------------------------
def turn_off_all_relays(io_extender):
    """Function to turn off all the relays"""
    io_extender.write16(ALL_RELAYS_OFF)

# ------------------------------------------------------------------------------
def swizzle_byte(byte):
    """Function to reverse the order of the bits in a byte"""

    swizzled_byte = 0

    for bit in range (0, 8):
        swizzled_byte |= ((byte & (1 << bit)) >> bit) << (7 - bit)

    return swizzled_byte

# ------------------------------------------------------------------------------
def swizzle_msb(value):
    """Function to reverse the order of the bits in the
upper byte of a 16-bit value
"""

    msb = (value & 0xFF00) >> 8
    lsb = value & 0xFF

    swizzled_msb = swizzle_byte(msb)

    return (swizzled_msb << 8) | lsb

# ------------------------------------------------------------------------------
def set_relays_to_pattern(load_pattern, io_extender):
    """Function to set the relays to the supplied load pattern,
performing the appropriate inversion (for active-low inputs) and
swizzling (for cabling quirk).
"""
    # Due to the fact that the "B" outputs are in the reverse order from
    # the "A" outputs on the Slice of PI/O board, the upper byte is
    # bit-swizzled.
    io_extender.write16(swizzle_msb(~load_pattern))

# ------------------------------------------------------------------------------
def prime_relays(io_extender):
    """Function to turn on each relay briefly (workaround for 'weak'
relay issue.
"""
    prime_pattern = 0x8000
    while prime_pattern:
        set_relays_to_pattern(prime_pattern, io_extender)
        sleep(0.02)
        prime_pattern >>= 1
    turn_off_all_relays(io_extender)

# ------------------------------------------------------------------------------
def generate_beep(on_time=0.2, off_time=0.1, stop_event=None):
    """Function to activate the piezo buzzer to generate a loud
beep. When called in a loop, the beep pulses in a warning pattern. The
on_time arg is the amount of time in seconds that the buzzer is on (0.1
second resolution) and the off_time arg is the amount of time in seconds
to wait after turning it off.  If the stop_event arg is not None, it
must be a threading.Event() object in which case it is checked every 0.1
second during the on time and off time and if set, the function returns
immediately.
"""
    # Calculate number of 0.1 second loops for both on and off
    on_loops = 1
    if on_time > 0.1:
        on_loops = int(on_time/0.1)

    off_loops = 1
    if off_time > 0.1:
        off_loops = int(off_time/0.1)

    # Turn on buzzer
    GPIO.output(BUZZER_GPIO, True)

    # Wait for on_time
    for loop in range(on_loops):
        # bail out now if stop event is set
        if stop_event and stop_event.is_set():
            continue
        sleep(0.1)

    # Turn off buzzer
    GPIO.output(BUZZER_GPIO, False)

    # Wait for off_time
    for loop in range(off_loops):
        # bail out now if stop event is set
        if stop_event and stop_event.is_set():
            continue
        sleep(0.1)

# ------------------------------------------------------------------------------
def prompt_and_wait_for_dpst_off(lcd):
    """Function to prompt the user to turn off the DPST switch and poll
until this occurs.  While polling, the warning pattern is sounded.
"""
    global global_lock

    # Create warning thread object
    warning_thread = SoundWarning(on_time=0.1, off_time=0.2)

    # Create scrolling message thread object
    msg_text = "Turn switch\nOFF now!!"
    lcd_msg = ScrollingMessage(msg_text, lcd, beep=False, lock=global_lock)

    if GPIO.input(DPST_GPIO) == DPST_ON:
        print_and_log("**********************************************************")
        print_and_log("Please turn the toggle switch OFF")
        print_and_log("**********************************************************")

        # start the warning and message threads
        warning_thread.start() # start the warning thread
        lcd_msg.start() # start the message thread

        # wait for the switch to be turned on
        while GPIO.input(DPST_GPIO) == DPST_ON:
            sleep(0.2)

        # stop the warning and message threads
        warning_thread.stop()
        lcd_msg.stop()

# ------------------------------------------------------------------------------
def read_adc(adc, chP=0, chN=1, starting_pga=6144):
    """Wrapper function around the readADCDifferential function.  It
first uses different PGA gain values until it finds the optimal range.
The optimal range is the largest one where the reading is greater than
1/3 of the range (or the smallest range if none of the larger ranges
meets this criterion). Plus we need to avoid using a range that is too
small to accomodate the reading. The assumption is that the ADC is most
accurate when the reading is near the middle of the range. If a reading
is slightly less than 1/3 of the range, it will be less than 2/3 of the
next smaller range and therefore not at risk for exceeding that
range. Once the optimal range has been determined, it takes several
readings and returns the average value, in volts.  This obviously
exploits the assumption for this application that the voltage at the ADC
is fairly stable.
"""

    # Determine optimal PGA range and then sample voltage at that PGA
    # gain value.  The pga_list has the largest range first and the
    # smallest range last.
    for pga in pga_list:
        if pga > starting_pga:
            continue
        millivolts = adc.readADCDifferential(chP, chN, pga, sps)
        #print_and_log("ChP: " + str(chP) + " ChN: " + str(chN) + "  PGA: " + str(pga) + "  mV: " + str(millivolts))
        millivolt_sum = millivolt_max = millivolt_min = millivolt_avg = millivolts
        if abs(millivolts) > pga / 3 or pga == pga_list[-1]:
            for sample_num in range (0, SAMPLES_PER_MEASUREMENT - 1):
                millivolts = adc.readADCDifferential(chP, chN, pga, sps)
                #print_and_log("ChP: " + str(chP) + " ChN: " + str(chN) + "  PGA: " + str(pga) + "  mV: " + str(millivolts))
                millivolt_sum += millivolts
                if millivolts > millivolt_max:
                    millivolt_max = millivolts
                if millivolts < millivolt_min:
                    millivolt_min = millivolts
            millivolt_avg = millivolt_sum / SAMPLES_PER_MEASUREMENT
            percent_in_range = abs((millivolt_avg / pga) * 100)
            #print_and_log(" ====> ChP: " + str(chP) + "  ChN: " + str(chN) + "  PGA: " + str(pga) + "  mV: " + str(millivolt_avg) + "    " + str(percent_in_range) + "% of range")
            break

    percent_error = abs(((millivolt_max - millivolt_min) / millivolt_avg) * 100)
    #print_and_log(" ====> ChP: " + str(chP) + "  ChN: " + str(chN) + "  PGA: " + str(pga) + "  mV: " + str(millivolt_avg) + "  +-" + str(percent_error) + "%")

    # If the error is > 5%, force the return value to the min or max -
    # whichever is closer to the average
    if percent_error > 5:
        if abs(millivolt_max - millivolt_avg) < abs(millivolt_min - millivolt_avg):
            millivolt_avg = millivolt_max
        else:
            millivolt_avg = millivolt_min

    # A measurement of smaller than +-1mV is assumed to be noise, and
    # the actual voltage is 0
    if abs(millivolt_avg) < 1:
        millivolt_avg = 0

    return millivolt_avg / 1000

# ------------------------------------------------------------------------------
def read_voc(adc):
    """Function to read the current Voc voltage, but return 0 for
voltages less than 300mV
"""
    voc_volts = VDIV_MULT * read_adc(adc, VDIV_CHP, VDIV_CHN, 6144)
    if abs(voc_volts) < 0.300:
        voc_volts = 0

    return voc_volts

# ------------------------------------------------------------------------------
def measure_voc(adc, lcd, msg_text):
    """Function to continually measure Voc (10 measurements/second).
Once a stable measurement is achieved, the user is prompted to turn the
DPST switch on.  Voc measurements continue to be taken until this
happens (or until the idle timeout time has passed in which case the
system is shut down).  The msg_text parameter should be a string or a
list of strings to prompt the user to turn on the toggle switch once the
Voc value is stable.  The reason it isn't hardcoded is so the message
that is displayed for the first iteration can be different from the
message displayed for subsequent iterations.  The passed value of
msg_text gets overridden when the idle timeout is close to expiring.  In
that case, the number of seconds remaining is counted down on the LCD
display and when the timer expires the system is shut down.  The only
way for the user to avoid the autoshutdown is to turn on the DPST
switch.
"""
    global global_lock

    # Initialize variables
    voc_volts = 0
    voc_amps = INFINITE_VAL
    voc_watts = 0
    voc_ohms = INFINITE_VAL
    prompt_printed = 0
    voc_volts_history = []
    voc_settled = 0

    # Create LCD message object with passed value of msg_text
    lcd_msg = ScrollingMessage(msg_text, lcd, beep=False, lock=global_lock)

    print_and_log("Measuring Voc until stable ....")
    lcd.clear()
    lcd.message('Measuring Voc\nuntil stable ...')

    # Capture time the while loop is entered
    start_time = time.time()

    # Loop until switch is turned on
    loop_count = 0
    while GPIO.input(DPST_GPIO) == DPST_OFF:

        loop_count += 1

        # Calculate how many seconds we've been in the loop
        loop_entry_time = time.time()
        seconds_in_loop = int(loop_entry_time) - int(start_time)

        # If the timeout has been reached, shut down
        if seconds_in_loop >= IDLE_TIMEOUT_SECONDS:
            lcd_msg.stop()
            global_lock.acquire()
            msg_text = "Shutting down\nnow!!"
            lcd_msg = ScrollingMessage(msg_text, lcd, beep=False, lock=None)
            lcd_msg.start()
            sleep(2)
            os.system("shutdown -h now")
            # The following are only needed if the previous line is
            # commented out
            lcd_msg.stop()
            reset_lcd(lcd)
            sleep(5)
            global_lock.release()

        # If the timeout is getting close, override the prompt message
        # with a beeping message containing the number of seconds
        # remaining
        elif seconds_in_loop >= (IDLE_TIMEOUT_SECONDS -
                                 IDLE_TIMEOUT_WARNING_SECONDS):
            lcd_msg.stop()
            msg_text = 'Auto shutdown\nin %d seconds!!' % (IDLE_TIMEOUT_SECONDS - seconds_in_loop)
            lcd_msg = ScrollingMessage(msg_text, lcd, beep=True, lock=global_lock)
            lcd_msg.start()

        # Take Voc measurements
        amm_volts = read_adc(adc, AMM_CHP, AMM_CHN, 6144)
        curr_voc_amps = (amm_volts / AMM_OP_AMP_GAIN) / AMM_SHUNT_RESISTANCE
        curr_voc_volts = read_voc(adc)
        log("Voc Amps: %.6f  Voc Volts: %.6f" % (curr_voc_amps, curr_voc_volts))

        # Return to caller now if voltage is negative
        if curr_voc_volts < 0.0:
            lcd_msg.stop()
            return (curr_voc_amps, curr_voc_volts, voc_ohms, voc_watts)

        # Need to check that switch is still off
        if GPIO.input(DPST_GPIO) == DPST_OFF:
            voc_amps = curr_voc_amps
            voc_volts = curr_voc_volts
            voc_watts = voc_volts * voc_amps

            # Keep a list of the voc_volts values from each iteration.
            # Only the most recent VOC_SETTLE_COUNT values are kept.  If
            # the list has VOC_SETTLE_COUNT entries and their standard
            # deviation is less than 0.01, the Voc value is considered
            # "settled", and the user is requested to turn the switch
            # on.  It is possible for the Voc value to become
            # "unsettled" while waiting for the user to flip the switch,
            # however, and in that case a warning is printed.
            voc_volts_history.append(voc_volts)
            del voc_volts_history[:-VOC_SETTLE_COUNT]  # trim to newest VOC_SETTLE_COUNT entries
            voc_volts_history_std = np.std(voc_volts_history) # standard deviation

            if voc_amps == 0 and len(voc_volts_history) == VOC_SETTLE_COUNT:
                if voc_volts_history_std < 0.01:
                    voc_settled = 1
                else:
                    voc_settled = 0

            if voc_settled and not prompt_printed:
                if voc_volts <= 0.0:
                    lcd_msg.stop()
                    return (voc_amps, voc_volts, voc_ohms, voc_watts)
                lcd.clear()
                lcd.message('Voc: %.2f V' % (voc_volts))
                sleep(1)
                print_and_log("**********************************************************")
                print_and_log("Please turn the toggle switch ON to begin IV curve tracing")
                print_and_log("**********************************************************")
                lcd_msg.start()
                prompt_printed = 1

        # Rate limit to 10 Voc measurements/second	
        elapsed_time = time.time() - loop_entry_time
        if elapsed_time < 0.1:
            sleep(0.1 - elapsed_time)

    print_and_log("Voc Volts: %.6f (standard deviation = %.6f over %d measurements)" %
                  (voc_volts, voc_volts_history_std, VOC_SETTLE_COUNT))

    if not voc_settled:
        print_and_log("   ===> WARNING: High Voc standard deviation; results may be unreliable")
        lcd_msg.stop()
        msg_text = ['==> WARNING:\nHigh Voc standard deviation',
                    'results may be\nunreliable']
        lcd_msg = ScrollingMessage(msg_text, lcd, beep=True, lock=global_lock)
        lcd_msg.start()
        sleep(7)

    lcd_msg.stop()
    return (voc_amps, voc_volts, voc_ohms, voc_watts)

# ------------------------------------------------------------------------------
def get_data_values_for_load_pattern(load_pattern, io_extender, adc, lcd):
    """Function to set the MCP23017 outputs (controlling the relays) to
the values based on the specified load pattern and to read the current
and voltage at that point.  Ohms and watts are calculated and the four
values are returned in a tuple.
"""
    # Set the relays to the provided pattern
    set_relays_to_pattern(load_pattern, io_extender)

    # Pause for TIME_BETWEEN_MEASUREMENTS before taking the voltage and
    # current readings.
    sleep(TIME_BETWEEN_MEASUREMENTS)

    # Take the current reading.  Retry a few times if the current is
    # zero, to attempt to work around failing relays. The retry toggles
    # the load pattern once in the hopes that contact will be made after
    # the toggle (but probably hastening the demise of the relays in the
    # process).
    amm_volts = read_adc(adc, AMM_CHP, AMM_CHN, 6144)
    log("AMM Volts: %.6f" % (amm_volts))
    amps = (amm_volts / AMM_OP_AMP_GAIN) / AMM_SHUNT_RESISTANCE
    retry_count = 0
    while(retry_count < MAX_RETRIES):
        if amps == 0:
            retry_count += 1
            print_str = "RETRY #%d for load_pattern 0x%x" % (retry_count, load_pattern)
            print_and_log(print_str)
            sleep(TIME_BETWEEN_MEASUREMENTS)
            set_relays_to_pattern(load_pattern, io_extender)
            sleep(TIME_BETWEEN_MEASUREMENTS)
            set_relays_to_pattern(load_pattern, io_extender)
            sleep(TIME_BETWEEN_MEASUREMENTS)
            amm_volts = read_adc(adc, AMM_CHP, AMM_CHN, 6144)
            log("AMM Volts: %.6f" % (amm_volts))
            amps = (amm_volts / AMM_OP_AMP_GAIN) / AMM_SHUNT_RESISTANCE
        else:
            break

    # Take the voltage reading
    volts = VDIV_MULT * read_adc(adc, VDIV_CHP, VDIV_CHN, 6144)

    # Calculate ohms and watts
    if amps == 0.0:
        ohms = INFINITE_VAL
    else:
        ohms = volts / amps

    watts = volts * amps

    # The relay switching sometimes causes the LCD to get messed up. We
    # should probably have a snubber circuit across every relay coil (in
    # addition to the snubbers across the contacts), but this software
    # workaround will do.  We just reset the LCD display before using it
    # after we've switched one or more relays (and after some time has
    # passed).
    reset_lcd(lcd)

    # Print current values formatted nicely
    print_amps = ("%.2f" % amps).rjust(5)
    print_volts = ("%.2f" % volts).rjust(5)
    print_ohms = ("%.2f" % ohms).rjust(5)
    print_watts = ("%.2f" % watts).rjust(6)
    print_str  =  "Amps: " + print_amps + "  Volts: " + print_volts
    print_str +=  "  Ohms: " + print_ohms + "  Watts: " + print_watts
    print_str +=  "  Load pattern: " + format(load_pattern, '#018b')
    print_and_log(print_str)
    lcd_str  = print_amps  + " A  " + print_volts + " V\n"
    lcd_str += print_ohms  + " R "  + print_watts + " W"
    lcd.message(lcd_str)

    return (amps, volts, ohms, watts)

# ------------------------------------------------------------------------------
def open_circuit(load_pattern, io_extender):
    """Function to activate the OPEN relay to open the circuit, while
keeping the other relays as they were. Once the OPEN relay is activated
(and after a short delay), the other relays are inactivated. The purpose
of this is to avoid inactivating the relays while current is
flowing. This completely eliminates any arcing on that side of the relay
(the Normally Open, "NO" side), which is the side without a snubber.
"""
    # Wait a short time
    sleep(TIME_BETWEEN_MEASUREMENTS)

    # Set the OPEN bit in the load_pattern passed in and apply that to
    # the relays
    load_pattern |= OPEN_ONLY
    set_relays_to_pattern(load_pattern, io_extender)

    # Wait a short time
    sleep(TIME_BETWEEN_MEASUREMENTS)

    # Turn off all other relays, leaving only the OPEN relay activated
    set_relays_to_pattern(OPEN_ONLY, io_extender)

    # Wait a short time
    sleep(TIME_BETWEEN_MEASUREMENTS)

# ------------------------------------------------------------------------------
def get_base_loads(none_data_point, voc_volts):
    """Function to determine the 'base load'.  This is some combo of the
50W power resistors to start with before adding the finer grained
heating coil loads.  The purpose is to center the fine-grained points
over the knee of the curve, where they do the most good.  The function
returns a list of the loads that need to be activated before the finer
grained loads are activated.
"""
    base_loads = BASE_0_OHM
    
    # The current at the NONE load is basically Isc.  The ratio
    # of Voc to Isc is roughly the resistance at the knee.
    approx_isc = none_data_point[AMPS_DATA_POINT]
    approx_knee_ohms = voc_volts / approx_isc

    # The base load adds to the resistance with no loads selected
    none_ohms = none_data_point[OHMS_DATA_POINT]

    # The ideal base load is the estimated knee load minus the
    # resistance of half of the unit load chain.  Half of the unit load
    # chain is SIX+HALF, which (from empirical data) is 5.6 ohms
    # (average 0.86 ohms per load).
    ideal_base_load = approx_knee_ohms - 5.6
    if ideal_base_load < (3 + none_ohms) or approx_isc > TWELVE_MAX_AMPS:
        base_loads = BASE_0_OHM
    elif ideal_base_load < (6 + none_ohms) or approx_isc > THIRTEEN_MAX_AMPS:
        print_and_log("Using 3 ohm base load")
        base_loads = BASE_3_OHM
    elif ideal_base_load < (9 + none_ohms):
        print_and_log("Using 6 ohm base load")
        base_loads = BASE_6_OHM
    elif ideal_base_load < (12 + none_ohms):
        print_and_log("Using 9 ohm base load")
        base_loads = BASE_9_OHM
    elif ideal_base_load < (15 + none_ohms):
        print_and_log("Using 12 ohm base load")
        base_loads = BASE_12_OHM
    elif ideal_base_load < (18 + none_ohms):
        print_and_log("Using 15 ohm base load")
        base_loads = BASE_15_OHM
    elif ideal_base_load < (21 + none_ohms):
        print_and_log("Using 18 ohm base load")
        base_loads = BASE_18_OHM
    else:
        print_and_log("Using 21 ohm base load")
        base_loads = BASE_21_OHM

    return base_loads

# ------------------------------------------------------------------------------
def swing_iv_curve(io_extender, adc, lcd, voc_volts):
    """Function to cycle through the load values using the relays,
taking a current and voltage measurement at each point.  The results are
returned in a list of 4-entry tuples (amps,volts,ohms,watts). If the
DIAG_MODE flag is set, the relays are activated individually.  If the
FINE_MODE flag is set, the load list containing all of the half and full
steps is used.  This wears out the HALF relay faster than the others,
but this is mitigated by skipping the half steps on parts of the curve
that are relatively straight lines.  If the FINE_MODE flag is not set,
the load list with full steps (starting with HALF) is used. An adaptive
algorithm is used to determine a 'base load', i.e. one or more of the
power resistors.  See the documentation for the get_base_loads function
for more information.
"""
    # Diag mode - activate each relay alone
    if DIAG_MODE:
        data_points = [(0,0,0,0)]  # placeholder for Isc
        for load_pattern in diag_load_list:
            data_point = get_data_values_for_load_pattern(load_pattern,
                                                          io_extender, adc, lcd)
            data_points.append(data_point)
        return data_points

    # Fine vs coarse mode
    if FINE_MODE:
        # FINE mode - better results, but wears out the HALF relay faster
        load_list = fine_load_list
    else:
        load_list = coarse_load_list

    data_points_unsorted = [(0,0,0,0)]  # placeholder for Isc
    base_load_pattern = NONE
    prev_load_pattern = 0xa5a5
    for load_pattern in load_list:
        skip_this_one = False
        load_pattern_with_base = load_pattern | base_load_pattern

        # Skip this measurement if the current load pattern is the same
        # as the previous one (which happens when using a
        # base_load_pattern).
        if load_pattern_with_base == prev_load_pattern:
            skip_this_one = True

        # Skip this measurement if we're in FINE mode, and the current
        # load pattern does not include the HALF load, AND the
        # previously measured point is very close to being in line with
        # its two predecessors.  The idea is to avoid the HALF steps
        # (which wear out the relay) if they add no value.  Note that
        # the FINE mode load list is out of order, i.e. the X_AND_A_HALF
        # loads precede the X loads.  So we optionally go backwards by
        # half a step when we determine that the curve is bending, which
        # adds resolution where we need it.  But where the line is
        # straight, we skip the half steps.
        #
        # We'll call the previous three measurements points 1, 2 and 3
        # (from oldest to newest). To determine if the curve is
        # "bending", we first need to calculate the slopes of the lines
        # through points 1 and 2 and points 2 and 3.  But we're
        # interested in the slopes as they appear visually on a graph
        # that is scaled at approximately the ratio of Voc to Isc.
        #
        #  Factor to scale current (I) values by:
        #    i_scale = Voc/Isc
        #
        #  Scaled (visual) slope of line through points 1 and 2:
        #    m12 = i_scale(i2 - i1)/(v2 - v1)
        #
        #  Scaled (visual) slope of line through points 2 and 3:
        #    m23 = i_scale(i3 - i2)/(v3 - v2)
        #
        # The angular difference between the lines is the difference in
        # the arctangents of their slopes.
        #
        #  rot_degrees = arctan(m12) - arctan(m23)
        #
        # One last factor to account for is the distance between the
        # points on the graph.  If the points are very close together,
        # it's not worth adding a point between them for the same
        # inflection angle as points that are farther apart.  The
        # scaling factor is needed for this calculation too.
        #
        # Distance between points 2 and 3:
        #    d23 = sqrt((v3 - v2)^2 + (i_scale(i3 - i2))^2)
        #
        # The final criterion for skipping the half-step point is:
        #
        # Skip if:
        #    rot_degrees * d23 < 50
        #
        # The threshold of 50 was determined empirically.
        #
        if FINE_MODE and load_pattern != NONE and (load_pattern & HALF_ONLY == 0):
            data_points_sorted = sorted(data_points_unsorted,
                                        key=lambda dp: dp[OHMS_DATA_POINT])
            i1 = data_points_sorted[-3][AMPS_DATA_POINT]
            v1 = data_points_sorted[-3][VOLTS_DATA_POINT]
            i2 = data_points_sorted[-2][AMPS_DATA_POINT]
            v2 = data_points_sorted[-2][VOLTS_DATA_POINT]
            i3 = data_points_sorted[-1][AMPS_DATA_POINT]
            v3 = data_points_sorted[-1][VOLTS_DATA_POINT]
            # The NONE data point is the closest we have to Isc now
            i_scale = voc_volts / data_points_sorted[1][AMPS_DATA_POINT]
            m12 = i_scale * (i2 - i1)/(v2 - v1)
            m23 = i_scale * (i3 - i2)/(v3 - v2)
            d23 = math.sqrt((v3 - v2)**2 + (i_scale * (i3 - i2))**2)
            rot_degrees = math.degrees(math.atan(m12)) - math.degrees(math.atan(m23))
            weight = abs(rot_degrees) * d23
            print_str  =   "m12: " + str(m12)
            print_str +=  " m23: " + str(m23)
            print_str +=  " d23: " + str(d23)
            print_str +=  " Rot degrees: " + str(rot_degrees)
            print_str +=  " Weight: " + str(weight)
            print_str +=  " Load pattern: " + format(load_pattern, '#018b')
            log(print_str)
            if weight < 50:
                skip_this_one = True
            else:
                log("ADDING HALF STEP POINT")

        # Unless we're skipping this point for one of the reasons above,
        # get its data values and add them to the list
        if not skip_this_one:
            data_point = get_data_values_for_load_pattern(load_pattern_with_base,
                                                          io_extender, adc, lcd)
            prev_load_pattern = load_pattern_with_base
            data_points_unsorted.append(data_point)

        # When the NONE measurement has been taken, determine if one or
        # more base loads are needed, and if so then get the data values
        # for the base load(s).  Set base_load_pattern to the OR of the
        # base loads so the sum of the loads will be included in the
        # pattern used above in the following iterations.
        if load_pattern == NONE:
            base_loads = get_base_loads(data_point, voc_volts)
            if base_loads != BASE_0_OHM:
                for base_load in base_loads:
                    base_load_pattern |= base_load
                    data_point = get_data_values_for_load_pattern(base_load_pattern,
                                                                  io_extender, adc, lcd)
                    prev_load_pattern = base_load_pattern
                    data_points_unsorted.append(data_point)

    # Activate the OPEN relay without changing others, and then
    # deactivate the others
    open_circuit(load_pattern, io_extender)

    # Sort the list in order of increasing resistance (needed because
    # the fine mode load list is out of order)
    data_points = sorted(data_points_unsorted,
                         key=lambda dp: dp[OHMS_DATA_POINT])

    return data_points


# ------------------------------------------------------------------------------
def get_max_watt_point_number(data_points):
    """Function to find and return the measured data point number with
the highest power.  The actual Maximum Power Point (MPP) is most likely
not exactly at this point, but somewhere between this point and one of
its neighbors and will be found later via interpolation.
"""
    data_point_num = 0
    max_watt_point_number = 0

    for data_point in data_points:
        if data_point[WATTS_DATA_POINT] > data_points[max_watt_point_number][WATTS_DATA_POINT]:
            max_watt_point_number = data_point_num
        data_point_num += 1

    return max_watt_point_number

# ------------------------------------------------------------------------------
def extrapolate_isc(data_points, max_watt_point_number):
    """Function to extrapolate the Isc value from the first two measured
data points.
"""
    i1 = data_points[1][AMPS_DATA_POINT]  # NONE data point
    v1 = data_points[1][VOLTS_DATA_POINT] 
    
    i2 = data_points[2][AMPS_DATA_POINT]  # HALF data point
    v2 = data_points[2][VOLTS_DATA_POINT]

    if v2 != v1 and max_watt_point_number > 3:
        # Find y (aka I) intercept of line connecting first two measured
        # points.
        #
        # We all remember the y = mx + b form of a linear equation. y is
        # current, x is voltage, and b is the y-intercept, i.e. Isc.
        # So:
        #
        #   i = mv + Isc
        #
        # m is slope = rise/run = (i2 - i1)/(v2 - v1)
        #
        # So now:
        #
        #    i = ((i2 - i1)/(v2 - v1)) * v + Isc
        #
        #  Isc = i - ((i2 - i1)/(v2 - v1)) * v
        #
        #  Since this equation is valid for any point (v, i) on the
        #  line, we can substitute i1 and v1 for i and v:
        #
        #  Isc = i1 - ((i2 - i1)/(v2 - v1)) * v1
        #
        isc_amps = i1 - ((i2 - i1)/(v2 - v1)) * v1

        # If the extrapolated value is greater than 2% more than the
        # measured NONE value, it's probaby because there aren't enough
        # sampled points at the beginning of the curve (e.g. if there's
        # a base load, but there is shading).  In that case, just return
        # a value 2% greater than the measured NONE value.
        if isc_amps > 1.02 * i1:
            isc_amps = 1.02 * i1
        
    else:
        # If the voltages of the first two points are equal (most likely
        # because both are zero - PV isn't connected), the equation
        # above gets a divide-by-zero error so we just set Isc to the
        # value of the first point.  Also if the highest measured power
        # is on one of the first three (or four) points, the knee of the
        # curve is too close to use a linear extrapolation from the
        # first two points since the second point is likely already
        # somewhat over the knee and the calculated Isc will be too
        # high.  So we just set Isc to the value of the first point in
        # that case too.
        isc_amps = i1

    isc_volts = 0
    isc_ohms = 0
    isc_watts = 0
    print_and_log("Isc Amps: %.6f" % (isc_amps))

    return (isc_amps, isc_volts, isc_ohms, isc_watts)

# ------------------------------------------------------------------------------
def write_csv_data_points_to_file(filename, data_points):
    """Function to write/append each of the CSV data points to the
output file.
"""
    with open(filename, "a") as f:
        # Write headings
        f.write("Volts, Amps, Watts, Ohms\n")
        # Write data points
        for data_point in data_points:
            write_csv_data_to_file(f,
                                   data_point[VOLTS_DATA_POINT],
                                   data_point[AMPS_DATA_POINT],
                                   data_point[WATTS_DATA_POINT],
                                   data_point[OHMS_DATA_POINT])

# ------------------------------------------------------------------------------
def write_csv_data_to_file(open_filehandle, volts, amps, watts, ohms):
    """Function to write/append the current voltage, current, watts, and
ohms values to an output file which the caller has opened for appending
and has passed the filehandle.
"""
    output_line = "%.3f,%.3f,%.3f,%.3f\n" % (volts,amps,watts,ohms)
    open_filehandle.write(output_line)

# ------------------------------------------------------------------------------
def write_gp_data_points_to_file(filename, data_points):
    """Function to write/append each of the gnuplot data points to the
output file.
"""
    with open(filename, "a") as f:
        for data_point in data_points:
            write_gp_data_to_file(f,
                                  data_point[VOLTS_DATA_POINT],
                                  data_point[AMPS_DATA_POINT],
                                  data_point[WATTS_DATA_POINT])

# ------------------------------------------------------------------------------
def write_gp_data_to_file(open_filehandle, volts, amps, watts, new_data_set=False):
    """Function to write/append the current voltage and current readings
to an output file which the caller has opened for appending and has
passed the filehandle.  If new_data_set=True, then the other values are
ignored and two blank lines are appended to the file.
"""
    output_line = "%.3f %.3f %.3f\n" % (volts,amps,watts)
    if new_data_set:
        # two blank lines signify a new data set to gnuplot
        open_filehandle.write("\n")
        open_filehandle.write("\n")
    else:
        open_filehandle.write(output_line)

# ------------------------------------------------------------------------------
def get_interpolation_func(force_linear_interpolation, data_points,
                           max_watt_point_number):
    """Function to derive the interpolation function from the data
points using the scipy library
"""
    # NOTE: I've given up on cubic spline interpolation for now, but
    # this function still supports it.

    success = 1

    # The first step is to populate two lists: one with the voltage (x)
    # values and one with the current (y) values. In addition to the
    # actual measured points (and the extrapolated Isc point), some
    # dummy points are added to improve the curve fitting results.
    voltage_values = []
    current_values = []
    data_point_num = 0
    for data_point in data_points:
        # Get Isc from the first point; we'll need it
        if data_point_num == 0:
            isc_amps = data_point[AMPS_DATA_POINT]

        # Add dummy points between the Isc point and the second measured
        # data point to dampen the overshoot of the cubic spline
        # interpolation.  It is assumed that this segment is a straight
        # line.
        if not force_linear_interpolation and (data_point_num == 1 or
                                               data_point_num == 2):
            volts = 0
            while volts < data_point[VOLTS_DATA_POINT]:
                #  i = Isc + (((i2 - i1)/v2) * v)
                amps = isc_amps + ((data_point[AMPS_DATA_POINT] -
                                    isc_amps)/data_point[VOLTS_DATA_POINT]) * volts
                log("amps: " + str(amps) + "   volts: " + str(volts))
                current_values.append(amps)
                voltage_values.append(volts)
                volts += 0.1

        # Add the measured point
        current_values.append(data_point[AMPS_DATA_POINT])
        voltage_values.append(data_point[VOLTS_DATA_POINT])

        data_point_num += 1

    # When the knee of the curve is sufficiently far into the data set,
    # cubic spline interpolation works well - especially when the dummy
    # points are added between the (extrapolated) Isc point and the
    # first measured point as above.  But when it comes too early in the
    # data set, cubic spline interpolation still has a large overshoot
    # effect and we are much better off with simple linear
    # interpolation.  A better solution *should* be to use Piecewise
    # Cubic Hermite Interpolation (PCHIP), but I had trouble getting
    # that to work.  It should only be for cases where the Voc is very
    # low (< 15V) that the linear interpolation will be used, and this
    # shouldn't be the case for any modern PV panels unless they are
    # faulty - in which case the linear curve will be perfectly
    # adequate.  For various (still mysterious) reasons, the cubic
    # spline interpolation sometimes fails so we fall back to linear
    # interpolation in those cases too instead of just crashing.
    if force_linear_interpolation:
        try:
            interpolation_func = interp1d(voltage_values, current_values, kind='linear')
        except:
            print_and_log("scipy.interp1d (linear) failed ... ")
            interpolation_func = 0
            success = 0
    else:
        try:
            interpolation_func = interp1d(voltage_values, current_values, kind='cubic')
        except:
            print_and_log("scipy.interp1d (cubic) failed ... ")
            interpolation_func = 0
            success = 0
    #interpolation_func = pchip(np.array(voltage_values), np.array(current_values))

    return (interpolation_func, success)

# ------------------------------------------------------------------------------
def generate_interpolated_data_set(sd_data_point_filename, data_points,
                                   linear_interpolation, interpolation_func):
    """Function to use interpolation to generate an interpolated data
set.  This data set includes all of the measured points as well as
points interpolated at 0.1 V intervals between the measured points
(unless linear interpolation is being used).
"""
    # NOTE: I've given up on cubic spline interpolation for now, but
    # this function still supports it.

    data_point_num = 0
    with open(sd_data_point_filename, "a") as f:
        # Add new data set delimiter
        write_gp_data_to_file(f, 0, 0, 0, new_data_set=True)

        for data_point in data_points:
            volts = data_point[VOLTS_DATA_POINT]
            write_gp_data_to_file(f,
                                  volts,
                                  data_point[AMPS_DATA_POINT],
                                  data_point[WATTS_DATA_POINT])

            # Unless we're doing linear interpolation, add interpolated
            # points at 0.1 volt intervals
            volts += 0.1
            if not linear_interpolation:
                if data_point_num < (len(data_points) - 1):
                    while volts < data_points[data_point_num+1][VOLTS_DATA_POINT]:
                        amps = interpolation_func(volts)
                        write_gp_data_to_file(f,
                                              volts,
                                              amps,
                                              volts * amps)
                        volts += 0.1

            data_point_num += 1

# ------------------------------------------------------------------------------
def interpolate_mpp(data_points, mpp_watt_point_number, interpolation_func):
    """Function to use interpolation to determine the maximum power
point
"""
    # Passed into the function is the list of data points and the point
    # number in that list that has the highest power of all the measured
    # data points.  The actual MPP could be on either side of that
    # point, so we start with the preceding point and "search" for the
    # MPP by calculating the power for each voltage value.  The voltage
    # is incremented by 10mV (0.01V) per step and the current is
    # calculated using the interpolation function that is passed in.  At
    # each point the power is calculated.  The search ends when the
    # calculated power is lower than the previous point's power - the
    # MPP amps, volts, and watts from the previous point are returned.
    # This is because the search window starts at a point below the MPP
    # and searches upward until the MPP is found.  NOTE: there is
    # probably a more mathematically elegant way to find the maximum
    # value of f(volts) = volts * interpolation_func(volts).  But even
    # with the slow RPi it's easier to be lazy and just do it this way,
    # which is plenty fast.

    # Initialize MPP values to the mpp_watt_point_number measured
    # values.
    mpp_amps = data_points[mpp_watt_point_number][AMPS_DATA_POINT]
    mpp_volts = data_points[mpp_watt_point_number][VOLTS_DATA_POINT]
    mpp_watts = data_points[mpp_watt_point_number][WATTS_DATA_POINT]

    # Start at previous measured point
    start_volts = data_points[mpp_watt_point_number-1][VOLTS_DATA_POINT]

    # End at next measured point (shouldn't get this far though)
    max_volts = data_points[mpp_watt_point_number+1][VOLTS_DATA_POINT]

    # Increment volts, calculating amps by interpolation until the MPP
    # is found
    prev_watts = 0
    volts = start_volts
    while volts < max_volts:
        amps = interpolation_func(volts)
        watts = volts * amps
        if watts > mpp_watts:
            mpp_amps = amps
            mpp_volts = volts
            mpp_watts = volts * amps
        if watts < prev_watts:
            # found it
            break
        prev_watts = watts
        volts += 0.01

    # Calculate resistance
    if mpp_amps == 0.0:
        mpp_ohms = INFINITE_VAL
    else:
        mpp_ohms = mpp_volts / mpp_amps

    # Print MPP
    print_and_log("==========================")
    print_and_log("Maximum power point (MPP): Amps: %.6f   Volts: %.6f   Ohms: %.6f   Watts: %.6f" % (mpp_amps, mpp_volts, mpp_ohms, mpp_watts))

    return (mpp_amps, mpp_volts, mpp_ohms, mpp_watts)

# ------------------------------------------------------------------------------
def write_gnuplot_file(command_filename, data_filename, pdf_filename,
                       isc_amps, voc_volts, mpp_amps, mpp_volts, linear):
    """Function to write the gnuplot command file"""
    with open(command_filename, "w") as f:
        # First set the terminal type to PDF and output to the PDF filename
        f.write("set terminal pdf size 11,8.5\n")
        output_line = "set output \"" + pdf_filename + "\"\n"
        f.write(output_line)

        # Set the title and X and Y labels for the plot
        f.write("set title \"IV Swinger Plot for " + data_filename + "\"\n")
        f.write("set xlabel \"Voltage (volts)\"\n")
        f.write("set ylabel \"Current (amps)\"\n")

        # Set the X and Y ranges to be 20% and 30% more than Voc and Isc
        # respectively
        max_x = voc_volts * 1.2
        if max_x > 0:
            output_line = "set xrange [0:" + str(max_x) + "]\n"
            f.write(output_line)
        max_y = isc_amps * 1.3
        if max_y > 0:
            output_line = "set yrange [0:" + str(max_y) + "]\n"
            f.write(output_line)

        # Display grid lines on graph
        if max_x < 20:
            output_line = "set xtics 1\n"
        else:
            output_line = "set xtics 2\n"
        f.write(output_line)
        if max_y < 5:
            output_line = "set ytics 0.5\n"
        else:
            output_line = "set ytics 1\n"
        f.write(output_line)
        output_line = "set grid\n"
        f.write(output_line)

        if PLOT_IDEAL_CURVE:
            # Define the ideal PV curve function for "fit"
            output_line = "ideal_curve(x) = " + str(isc_amps) + " - (a * (exp(b * x) - 1))\n"
            f.write(output_line)
            # Suppress verbosity from "fit"
            f.write("set fit quiet\n")
            # Run curve fitting
            output_line = "fit ideal_curve(x) \"" + data_filename + "\" via a, b\n"
            f.write(output_line)

        # Put a label on the Isc point
        isc_amps_str = "%.2f" % (isc_amps)
        output_line = "set label at 0," + str(isc_amps) + " \"Isc = " + isc_amps_str + " A \" point pointtype 7 offset 1,1\n"
        f.write(output_line)

        # Put a label on the MPP
        mpp_watts_str = "%.2f" % (mpp_volts * mpp_amps)
        mpp_volts_x_amps_str = "%.2f * %.2f" % (mpp_volts, mpp_amps)
        output_line = "set label at " + str(mpp_volts) + "," + str(mpp_amps) + " \"  MPP = " + mpp_watts_str + " W (" + mpp_volts_x_amps_str + ")\" point pointtype 7\n"
        f.write(output_line)

        # Put a label on the Voc point
        voc_volts_str = "%.2f" % (voc_volts)
        output_line = "set label at " + str(voc_volts) + ",0 \"Voc = " + voc_volts_str + " V \" point pointtype 7 offset 1,1\n"
        f.write(output_line)

        # Build and run the plot command with three plots:
        #   - measured data points as points
        #   - interpolated (or smoothed) curve through measured points
        #   - ideal curve (optional)
        output_line = "plot \"" + data_filename + "\" index 0 title \"Measured Points\" pointtype 6 linewidth 4"
        if PLOT_INTERPOLATED_CURVE:
            output_line += ", "
            if linear:
                type_str = "Linear"
            else:
                type_str = "Cubic Spline"
            output_line += "\"" + data_filename + "\" index 1 with lines title "
            output_line += "\"" + type_str + " Interpolated Curve\" "
            output_line += "linecolor rgb \"blue\" linewidth 6 linetype 3"
        elif PLOT_SMOOTHED_CURVE:
            output_line += ", "
            output_line += "\"" + data_filename + "\" index 0 using 1:2 smooth csplines title \"Cubic Spline Smoothed Curve\" linecolor rgb \"blue\" linewidth 6 linetype 3"
        if PLOT_IDEAL_CURVE:
            output_line += ", "
            output_line += " ideal_curve(x) title \"Ideal Curve\" linecolor rgb \"purple\" linewidth 6 linetype 3"
        output_line += "\n"
        f.write(output_line)

        # Now set the terminal to wxt (default dynamic display) and
        # re-run the plot.  This needs to be suppressed in headless
        # mode.
        if not HEADLESS_MODE:
            f.write("set terminal wxt size 1200,800\n")
            output_line = "unset output\n"
            f.write(output_line)
            f.write("replot\n")
            f.write("pause -1\n")

# ------------------------------------------------------------------------------
def plot_with_gnuplot (sd_gp_command_filename,
                       sd_data_point_filename, sd_pdf_filename,
                       isc_amps, voc_volts, mpp_amps, mpp_volts, lcd, linear):
    """Function to generate the graph with gnuplot"""

    # Write the gnuplot command file
    write_gnuplot_file(sd_gp_command_filename,
                       sd_data_point_filename, sd_pdf_filename,
                       isc_amps, voc_volts, mpp_amps, mpp_volts, linear)

    # Execute the gnuplot command file
    if isc_amps and voc_volts:
        # FIXME: redirect of stderr to /dev/null shouldn't be necessary
        # (and makes debugging impossible!); but currently there are
        # annoying Glib warnings that I want to suppress
        #FNULL = open(os.devnull, 'w')
        #call(["gnuplot", sd_gp_command_filename], stderr=FNULL)
        call(["gnuplot", sd_gp_command_filename])

# ------------------------------------------------------------------------------
def clean_up (io_extender, lcd, reason_text):
    """Function to clean up on exit"""

    print_and_log("Cleaning up on exit")

    # Turn off all relays
    turn_off_all_relays(io_extender)

    # Need user to turn off the DPST switch
    prompt_and_wait_for_dpst_off(lcd)

    # Display exit message on LCD
    lcd.clear()
    lcd.message('IV_Swinger exit:\n' + reason_text)

    # Clean up GPIO
    GPIO.cleanup()

# ------------------------------------------------------------------------------
def scrolling_message (text, lcd, stop_event=None, repeat_count=0, beep=False, lock=None):
    """Function to display a longer message on the 16x2 LCD display.
The message must be 80 or fewer characters, and if it contains a \n,
there must be 40 or fewer characters before and after the \n.  The 16x2
LCD display has memory for 40 characters per line, but only shows 16.
This function scrolls the message left once (unless repeat_count is
non-zero) so that the whole message can be read. If the caller doesn't
include a \n, the first line will contain the first 40 characters and
the second will contain the remainder, with the split not necesssarily
coming between words.  If the beep arg is set, sound the beep once per
repetition.  If the stop_event arg is not None, it must be a
threading.Event() object in which case it is checked during the
scrolling and if set, the display is returned to the home position and
the function returns immediately.  If the lock arg is not None, it must
be a threading.Lock() object in which case it is acquired and released
around each LCD object method call.  The first of these is blocking, but
the others are non-blocking.  For those that are non-blocking, the
function returns if the lock is not acquired.
"""

    # Init variables
    char_count = [0,0] # List containing character counts for each line
    line = 0
    newline_count = 0

    # Count characters per line and check that there is no more than one
    # newline
    for char in text:
        if char == '\n':
            line = 1
            newline_count += 1
            if newline_count > 1:
                print_and_log("ERROR (scrolling_message): More than two lines in text:\n" + text)
                exit(-1)
        else:
            char_count[line] += 1

    # Check character limits (40 per line or 80 total)
    if char_count[1] > 0:
        if char_count[0] > LCD_MEM_CHARS_PER_LINE:
            print_and_log("ERROR (scrolling_message): >40 characters before newline in text:\n" + text)
            exit(-1)
        elif char_count[1] > LCD_MEM_CHARS_PER_LINE:
            print_and_log("ERROR (scrolling_message): >40 characters after newline in text:\n" + text)
            exit(-1)
    elif char_count[0] > LCD_LINES * LCD_MEM_CHARS_PER_LINE:
        print_and_log("ERROR (scrolling_message): >80 characters in text:\n" + text)
        exit(-1)

    # Determine maximum number of characters in longer line and number
    # of hidden characters in that line
    if char_count[0] > LCD_MEM_CHARS_PER_LINE:
        max_chars = LCD_MEM_CHARS_PER_LINE
    elif char_count[0] > char_count[1]:
        max_chars = char_count[0]
    else:
        max_chars = char_count[1]
    hidden_chars = max_chars - LCD_DISPLAY_CHARS_PER_LINE

    # Calculate the number of scrolls needed to show hidden characters
    float_chars_per_scroll = float(LCD_CHARS_PER_SCROLL)
    num_scrolls = int(math.ceil(hidden_chars/float_chars_per_scroll))

    # Display the message unscrolled for a short time
    if lock:
        lock.acquire() # blocking
    lcd.clear()
    lcd.message(text)
    if lock:
        lock.release()
    if beep:
        generate_beep()
    sleep(LCD_SCROLL_DELAY)

    # Scroll the message the calculated number of times and repeat the
    # whole thing the requested number of times
    for rep_num in range (0, repeat_count + 1):
        for scroll in range (0, num_scrolls):
            for shift in range (0, LCD_CHARS_PER_SCROLL):
                got_lock = True
                if lock:
                    got_lock = lock.acquire(0) # non-blocking
                if got_lock:
                    # shift left once
                    lcd.DisplayLeft()
                    if lock:
                        lock.release()
                else:
                    return
            # bail out now if stop event is set
            if stop_event and stop_event.is_set():
                lcd.home()
                return
            # pause so it's visible
            sleep(LCD_SCROLL_DELAY)
        got_lock = True
        if lock:
            got_lock = lock.acquire(0) # non-blocking
        if got_lock:
            # back to beginning of message
            lcd.home()
            if lock:
                lock.release()
        else:
            return

        if repeat_count:
            # bail out now if stop event is set
            if stop_event and stop_event.is_set():
                return
            if beep:
                generate_beep()
            # pause before next repetition
            sleep(LCD_SCROLL_DELAY)

# ------------------------------------------------------------------------------
def find_usb_drives_inner ():
    """Inner function (used by find_usb_drives) to find all USB drives
and return the list.  USB drives look like directories under /media.
But there could be directories under /media that are not USB drives.  So
filter out any that are not mount points.  It's also possible that a USB
drive is write-protected so filter those out too.
"""
    # Get list of directories under /media (possible USB drives)
    slash_media_dir_glob = "/media/*"
    slash_media_dirs = glob.glob(slash_media_dir_glob)

    # Filter out any that are not actually mount points or are not
    # writeable (and executable, which is necessary to add
    # subdirectories/files).
    usb_drives = []
    for slash_media_dir in slash_media_dirs:
        if os.path.ismount(slash_media_dir) and os.access(slash_media_dir,
                                                          os.W_OK|os.X_OK):
            # Instead of using os.path.ismount and os.access, could look
            # in /proc/mounts and check that it is "rw"

            # Check for duplicates
            duplicate = False
            for usb_drive in usb_drives:
                if os.path.samefile(usb_drive,slash_media_dir):
                    duplicate = True

            # Add to the list if not a duplicate
            if not duplicate:
                usb_drives.append(slash_media_dir)

    return usb_drives

# ------------------------------------------------------------------------------
def find_usb_drives (lcd, wait=True, display=False):
    """Function to find all USB drives and return the list. If the
'wait' arg is set to True and no USB drives are found, prompt the user
and wait until one is inserted (or time out).
"""
    global global_lock

    # Find USB drives
    usb_drives = find_usb_drives_inner()

    # If there are no USB drives, print warning and loop waiting for one
    # to be inserted
    if not usb_drives and wait:
        print_and_log("No USB drives!! Insert one or more USB drives now")

        start_time = time.time()

        while True:
            wait_time = int(time.time()) - int(start_time)
            time_left = 30 - wait_time
            if time_left < 0:
                time_left = 0
            msg_text = ['No USB drives!!\nInsert one or',
                        'more USB drives\nin next %d sec' % time_left]
            lcd_msg = ScrollingMessage(msg_text, lcd, beep=True, lock=global_lock)
            lcd_msg.start()

            # Sleep for a second
            sleep(1)

            # After 30 seconds of polling for a USB drive, time out and
            # display a message that the files will be copied to USB if
            # one is inserted later
            if wait_time > 30:
                lcd_msg.stop()
                msg_text = ['Proceeding\nwithout USB',
                            'Results will\nbe kept on SD',
                            'card and copied\nto USB drive',
                            'when one is\navailable']
                print_and_log("Proceeding without USB drive. Results will be kept on SD card and copied to USB when one is available")
                lcd_msg = ScrollingMessage(msg_text, lcd, beep=False, lock=global_lock)
                lcd_msg.start()
                sleep(10)
                lcd_msg.stop()
                break

            # Check again
            usb_drives = find_usb_drives_inner()
            if usb_drives:
                display = True
                lcd_msg.stop()
                break

            lcd_msg.stop()

    if display:
        usb_drives_str = ""
        for usb_drive in usb_drives:
            usb_drives_str += usb_drive + " "

        msg_text = ['Found USB drive(s):\n%s' % usb_drives_str]
        print_and_log("Found USB drive(s): %s" % usb_drives_str)
        lcd_msg = ScrollingMessage(msg_text, lcd, beep=False, lock=global_lock)
        lcd_msg.start()
        sleep(5)
        lcd_msg.stop()

    return usb_drives

# ------------------------------------------------------------------------------
def create_iv_swinger_dirs (base_dirs):
    """Function to create the IV_Swinger directories under the specified
base directories.  Returns the list of IV_swinger directories.
"""
    global global_lock

    iv_swinger_dirs = []

    # In each of the base directories make the IV_Swinger directory if
    # it doesn't already exist.  Also make the /IV_Swinger/clogs,
    # /IV_Swinger/csv and /IV_Swinger/pdf directories.
    for base_dir in base_dirs:
        sub_dirs = [base_dir + "/IV_Swinger",
                    base_dir + "/IV_Swinger/logs",
                    base_dir + "/IV_Swinger/csv",
                    base_dir + "/IV_Swinger/pdf"]
        for sub_dir in sub_dirs:
            if not os.path.exists(sub_dir):
                try:
                    os.makedirs(sub_dir)
                except:
                    msg_text = ['Failed to make\ndirectory:',
                                '%s' % sub_dir]
                    print_and_log("Failed to make directory: %s" % sub_dir)
                    lcd_msg = ScrollingMessage(msg_text, lcd, beep=True, lock=global_lock)
                    lcd_msg.start()
                    sleep(5)
                    lcd_msg.stop()
                    continue

        iv_swinger_dirs.append(sub_dirs[0])

    return iv_swinger_dirs

# ------------------------------------------------------------------------------
def copy_files_to_usb (lcd, date_time_str, sd_output_dir, sd_iv_swinger_dir):
    """Function to copy the files from the SD card /IV_Swinger directory
to the USB drives.  If no USB drive is found, the date/time string is
added to the file /IV_Swinger/pending_usb_copy.  If one or more USB
drives is found this time, any files from previous runs that were never
copied to USB (i.e. those listed in /IV_Swinger/pending_usb_copy) are
copied now - in addition to the files for the current run.
"""
    global log_file_name

    # Update USB drives list
    usb_drives = find_usb_drives(lcd, wait=False, display=False)

    if usb_drives:
        # Create IV_Swinger directories on the USB drives
        usb_iv_swinger_dirs = create_iv_swinger_dirs(usb_drives)

        # Copy the SD card directory to the directories on the USB
        # drives
        for usb_iv_swinger_dir in usb_iv_swinger_dirs:
            # Copy the log file
            usb_logs_dir = usb_iv_swinger_dir + "/logs"
            shutil.copy(log_file_name, usb_logs_dir)

            # Copy the output files
            usb_output_dir = usb_iv_swinger_dir + "/" + date_time_str
            log("copytree: %s to %s" % (sd_output_dir, usb_output_dir))
            shutil.copytree(sd_output_dir, usb_output_dir)

            # Copy the CSV and PDF files to the /csv and /pdf directories
            for file_type in ["csv","pdf"]:
                file_glob = sd_output_dir + "/*." + file_type
                files = glob.glob(file_glob)
                for f in files:
                    shutil.copy(f, usb_iv_swinger_dir + "/" + file_type)

        # If pending_usb_copy file exists, open it for reading
        # and step through the date_time_str values and use
        # copytree to copy the directory from SD to USB.  Then
        # remove the file.
        filename = sd_iv_swinger_dir + "/pending_usb_copy"
        if os.path.isfile(filename):
            try:
                with open(filename, "r") as f:
                    for my_date_time_str in f.read().splitlines():
                        sd_output_dir = sd_iv_swinger_dir + "/" + my_date_time_str
                        for usb_iv_swinger_dir in usb_iv_swinger_dirs:
                            usb_output_dir = usb_iv_swinger_dir + "/" + my_date_time_str
                            print_and_log("copytree: %s to %s" % (sd_output_dir, usb_output_dir))
                            shutil.copytree(sd_output_dir, usb_output_dir)
                            for file_type in ["csv","pdf"]:
                                file_glob = sd_output_dir + "/*." + file_type
                                files = glob.glob(file_glob)
                                for f in files:
                                    shutil.copy(f, usb_iv_swinger_dir + "/" + file_type)
                    os.remove(filename)
            except IOError as e:
                print_and_log("({})".format(e))
    else:
        # If no USB drives, append date_time_str to
        # pending_usb_copy file in SD IV_Swinger directory
        filename = sd_iv_swinger_dir + "/pending_usb_copy"
        try:
            with open(filename, "a") as f:
                f.write(date_time_str + "\n")
        except IOError as e:
            print_and_log("({})".format(e))

# ------------------------------------------------------------------------------
def main_meat (io_extender, lcd):
    """Function containing most of main(), run with exception handling
after io_extender object creation
"""
    global global_lock

    # Create ADS1115 ADC instance
    adc = ADS1x15(ic=ADS1115)

    # Turn off all relays
    turn_off_all_relays(io_extender)

    # Find USB drives
    usb_drives = find_usb_drives(lcd, wait=True, display=False)

    msg_text = ['Turn switch ON',
                'to begin IV\ncurve tracing']

    while True:
        # Block until global lock is acquired, then release it
        # immediately
        global_lock.acquire()
        global_lock.release()

        # Check the DPST switch state.  If it is ON, ask the user to turn it
        # off and poll it until that happens.
        prompt_and_wait_for_dpst_off(lcd)

        # Activate each relay once by itself. This is a workaround for a
        # problem of unknown cause where some relays especially near the
        # end of the chain) sometimes fail to stay in the activated
        # position.  This seems to help.
        #prime_relays(io_extender);

        # Continually measure Voc while waiting for the DPST switch to be
        # turned ON
        (voc_amps, voc_volts, voc_ohms, voc_watts) = measure_voc(adc,lcd,msg_text)

        # Attempt to acquire global lock
        got_lock = global_lock.acquire(0) # non-blocking

        # If the lock is busy (i.e. held by the pushbutton callback), go
        # back the beginning of the main loop and wait until it is free
        if got_lock == False:
            continue

        lcd.clear()
        lcd.message('Voc: %.2f V' % (voc_volts))
        sleep(0.5)

        if voc_volts < 0.0:
            msg_text = "Voc is negative!!\nDISCONNECT PV *NOW* TO AVOID DAMAGE!!"
            print_and_log(msg_text)
            lcd_msg = ScrollingMessage(msg_text, lcd, beep=False, lock=None)
            lcd_msg.start()
            while voc_volts < 0.0:
                voc_volts = read_voc(adc)
                generate_beep()
            lcd_msg.stop()
            global_lock.release()
            msg_text = ['Turn switch ON',
                        'to begin IV\ncurve tracing']
            continue
        elif voc_volts == 0.0:
            msg_text = "Voc is 0 volts!!\nConnect PV now"
            print_and_log(msg_text)
            warning_thread = SoundWarning(on_time=0.1, off_time=10)
            warning_thread.start()
            while voc_volts == 0.0:
                lcd_msg = ScrollingMessage(msg_text, lcd, beep=False, lock=None)
                lcd_msg.start()
                sleep(1.0)
                lcd_msg.stop()
                # Release the lock to give the pushbutton callback
                # thread a chance to grab it
                global_lock.release()
                sleep(0.01) # yield to callback thread
                global_lock.acquire()
                voc_volts = read_voc(adc)
            warning_thread.stop()
            global_lock.release()
            msg_text = ['Turn switch ON',
                        'to begin IV\ncurve tracing']
            continue
        else:
            # Form the date/time string used for the directory names.
            # Note that the date/time is when the DPST switch is turned
            # on.
            #date_time_str = datetime.now().strftime('%Y-%m-%d_%H_%M_%S')
            date_time_str = datetime.now().strftime('%y%m%d_%H_%M_%S')

            # Swing out the IV curve!
            data_points = swing_iv_curve(io_extender, adc, lcd, voc_volts)

            # Release lock
            global_lock.release()

            # Ask user to turn off the DPST switch
            prompt_and_wait_for_dpst_off(lcd)

            # Turn off all relays
            turn_off_all_relays(io_extender)

            # Clean up LCD after relay switching
            reset_lcd(lcd)

            # Find the measured point number with the highest power
            max_watt_point_number = get_max_watt_point_number(data_points)

            # Extrapolate Isc value and store in first element of data_points
            # list (overwrite placeholder)
            data_points[0] = extrapolate_isc(data_points, max_watt_point_number)
            isc_amps = data_points[0][AMPS_DATA_POINT]

            # Add Voc values to the end of the data point list
            voc_data_point = (voc_amps, voc_volts, voc_ohms, voc_watts)
            data_points.append(voc_data_point)

            # Create the SD card output directory
            sd_iv_swinger_dirs = create_iv_swinger_dirs([""])
            sd_iv_swinger_dir = sd_iv_swinger_dirs[0] # only one
            sd_output_dir = sd_iv_swinger_dir + "/" + date_time_str
            os.makedirs(sd_output_dir)

            # Create the leaf file names
            csv_data_point_leaf_name = "data_points_" + date_time_str + ".csv"
            gp_command_leaf_name = "gp_command_file_" + date_time_str
            gp_data_point_leaf_name = "gp_data_points_" + date_time_str
            gp_pdf_leaf_name = "gp_data_points_" + date_time_str + ".pdf"

            # Get the full-path names of the SD card output files
            sd_csv_data_point_filename = sd_output_dir + "/" + csv_data_point_leaf_name
            sd_gp_command_filename = sd_output_dir + "/" + gp_command_leaf_name
            sd_gp_data_point_filename = sd_output_dir + "/" + gp_data_point_leaf_name
            sd_gp_pdf_filename = sd_output_dir + "/" + gp_pdf_leaf_name

            # Write the CSV data points to the SD card file
            write_csv_data_points_to_file(sd_csv_data_point_filename,
                                          data_points)

            # Write the gnuplot data points to the SD card files
            write_gp_data_points_to_file(sd_gp_data_point_filename,
                                         data_points)

            # Get the linear interpolation function
            result = get_interpolation_func(True,
                                            data_points,
                                            max_watt_point_number)
            interpolation_func = result[0]
            success = result[1]

            if success:
                # Find the linear interpolation MPP
                linear_mpp_data_point = interpolate_mpp(data_points,
                                                        max_watt_point_number,
                                                        interpolation_func)
                linear_mpp_amps = linear_mpp_data_point[AMPS_DATA_POINT]
                linear_mpp_volts = linear_mpp_data_point[VOLTS_DATA_POINT]
                linear_mpp_watts = linear_mpp_data_point[WATTS_DATA_POINT]

                # Use the linear interpolation function to generate a
                # second data set that will be plotted with (overlayed
                # onto) the data points
                generate_interpolated_data_set(sd_gp_data_point_filename,
                                               data_points,
                                               True,
                                               interpolation_func)

            # Print MPP power
            global_lock.acquire()
            lcd.clear()
            lcd.message(' Max Power:\n     %.2f W' % (linear_mpp_watts))
            sleep(2)
            global_lock.release()

            if voc_volts != 0.0:
                # Plot with gnuplot
                plot_with_gnuplot(sd_gp_command_filename,
                                  sd_gp_data_point_filename,
                                  sd_gp_pdf_filename,
                                  isc_amps, voc_volts,
                                  linear_mpp_amps,
                                  linear_mpp_volts, lcd, True)

            # Copy CSV and PDF files to /IV_Swinger/csv and /IV_Swinger/pdf
            for file_type in ["csv","pdf"]:
                file_glob = sd_output_dir + "/*." + file_type
                files = glob.glob(file_glob)
                for f in files:
                    shutil.copy(f, sd_iv_swinger_dir + "/" + file_type)

            # Copy files to USB
            copy_files_to_usb(lcd, date_time_str,
                              sd_output_dir, sd_iv_swinger_dir)

            # Display message
            outdir_msg = "Output folder:\n" + date_time_str
            print_and_log(outdir_msg)
            print_and_log("")
            lcd_msg = ScrollingMessage(outdir_msg, lcd, beep=False, lock=global_lock)
            lcd_msg.start()
            sleep(3)
            lcd_msg.stop()
            msg_text = [outdir_msg, 'Turn switch ON\nto start again']


############
### Main ###
############
def main():
    global lcd, global_lock, log_file_name

    # Create logs directory and generate log file name
    logs_dir = "/IV_Swinger/logs"
    date_time_str = datetime.now().strftime('%y%m%d_%H_%M_%S')
    log_file_name = logs_dir + "/" + "log_" + date_time_str
    if not os.path.exists(logs_dir):
        try:
            os.makedirs(logs_dir)
        except:
            msg_text = ['Failed to make\ndirectory:',
                        '%s' % logs_dir]
            lcd_msg = ScrollingMessage(msg_text, lcd, beep=True, lock=global_lock)
            lcd_msg.start()
            sleep(5)
            lcd_msg.stop()

    # Create the global lock. This is used to arbitrate between the
    # pushbutton callback thread and the other (including main) threads.
    # It is a global object because there's no way that I can tell to
    # add parameters to the callback function.  This is also why the LCD
    # object has to be global.  I'd love to figure out how to do this
    # without using globals.
    global_lock = threading.Lock()

    # Create character LCD instance
    lcd = Adafruit_CharLCD()
    reset_lcd(lcd)

    # Set up GPIO pins
    set_up_gpio()

    # Print welcome message
    msg_text = "Welcome to\n     IV Swinger!"
    print_and_log(msg_text)

    global_lock.acquire()
    lcd.message(msg_text)
    global_lock.release()

    # The scipy and numpy imports take a few seconds, so in order to get
    # the welcome message printed earlier (and do something useful while
    # it is being displayed) we do the imports here - a bit
    # unconventional I know (and two more globals)
    global interp1d, np
    from scipy.interpolate import interp1d as interp1d
    import numpy as np

    # Create MCP23017 I/O extender instance and set all pins as outputs
    io_extender = Adafruit_MCP230XX(MCP23017_I2C_ADDR, MCP23017_PIN_COUNT)
    for pin in range(0, MCP23017_PIN_COUNT):
        io_extender.config(pin, io_extender.OUTPUT)

    # Run the rest with all exceptions causing a call to the clean_up
    # function
    try:
        main_meat(io_extender, lcd)
    except SystemExit:
        # explicit calls to exit() - which print their own explanation
        clean_up(io_extender, lcd, "explicit exit()")
    except KeyboardInterrupt:
        # Ctrl-C
        print_and_log("Keyboard interrupt - exiting")
        clean_up(io_extender, lcd, "kbd interrupt")
    except:
        # Everything else
        print_and_log("Unexpected error: " + str(sys.exc_info()[0]))
        print_and_log(traceback.format_exc())
        clean_up(io_extender, lcd, str(sys.exc_info()[0]))
        raise

# Boilerplate main() call
if __name__ == '__main__':
  main()
